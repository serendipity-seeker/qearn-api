// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
    include_str!("E:\\Work\\devwork\\axum-postgres-template\\prisma\\schema.prisma");
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod tick_info {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "TickInfo";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod tick {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "tick";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTick(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Tick(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Tick(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Tick(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Tick, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementTick(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementTick(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyTick(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideTick(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Tick(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Tick(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod duration {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "duration";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDuration(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Duration(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Duration(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Duration(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            Duration,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementDuration(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementDuration(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyDuration(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideDuration(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Duration(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Duration(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod epoch {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "epoch";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEpoch(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Epoch(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Epoch(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Epoch(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Epoch, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementEpoch(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementEpoch(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyEpoch(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideEpoch(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Epoch(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Epoch(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod initial_tick {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "initial_tick";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetInitialTick(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::InitialTick(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::InitialTick(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::InitialTick(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            InitialTick,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementInitialTick(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementInitialTick(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyInitialTick(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideInitialTick(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InitialTick(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InitialTick(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        tick: i64,
        duration: i64,
        epoch: i32,
        initial_tick: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i32, i64, Vec<SetParam>) {
        (tick, duration, epoch, initial_tick, _params)
    }
    pub fn create_unchecked(
        tick: i64,
        duration: i64,
        epoch: i32,
        initial_tick: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i32, i64, Vec<SetParam>) {
        (tick, duration, epoch, initial_tick, _params)
    }
    #[macro_export]
    macro_rules ! _select_tick_info { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tick_info :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tick_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tick_info :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tick_info :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tick_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tick_info :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , tick , duration , epoch , initial_tick , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: tick_info :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tick_info :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tick_info :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tick_info :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "tick" , "duration" , "epoch" , "initial_tick" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tick_info :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; tick) => { i64 } ; (@ field_type ; duration) => { i64 } ; (@ field_type ; epoch) => { i32 } ; (@ field_type ; initial_tick) => { i64 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TickInfo" , available relations are "id, tick, duration, epoch, initial_tick, created_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: tick_info :: SelectParam > :: into (crate :: prisma :: tick_info :: id :: Select) } ; (@ selection_field_to_selection_param ; tick) => { Into :: < crate :: prisma :: tick_info :: SelectParam > :: into (crate :: prisma :: tick_info :: tick :: Select) } ; (@ selection_field_to_selection_param ; duration) => { Into :: < crate :: prisma :: tick_info :: SelectParam > :: into (crate :: prisma :: tick_info :: duration :: Select) } ; (@ selection_field_to_selection_param ; epoch) => { Into :: < crate :: prisma :: tick_info :: SelectParam > :: into (crate :: prisma :: tick_info :: epoch :: Select) } ; (@ selection_field_to_selection_param ; initial_tick) => { Into :: < crate :: prisma :: tick_info :: SelectParam > :: into (crate :: prisma :: tick_info :: initial_tick :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: tick_info :: SelectParam > :: into (crate :: prisma :: tick_info :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tick_info :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; tick) => { "tick" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; epoch) => { "epoch" } ; (@ field_serde_name ; initial_tick) => { "initial_tick" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_tick_info as select;
    pub enum SelectParam {
        Id(id::Select),
        Tick(tick::Select),
        Duration(duration::Select),
        Epoch(epoch::Select),
        InitialTick(initial_tick::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Tick(data) => data.to_selection(),
                Self::Duration(data) => data.to_selection(),
                Self::Epoch(data) => data.to_selection(),
                Self::InitialTick(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_tick_info { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tick_info :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tick_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tick_info :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tick_info :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tick_info :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tick_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tick_info :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tick_info :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub tick : i64 , pub duration : i64 , pub epoch : i32 , pub initial_tick : i64 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: tick_info :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (tick) , stringify ! (duration) , stringify ! (epoch) , stringify ! (initial_tick) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tick_info :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: tick_info :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: tick_info :: tick :: NAME , & self . tick) ? ; state . serialize_field (crate :: prisma :: tick_info :: duration :: NAME , & self . duration) ? ; state . serialize_field (crate :: prisma :: tick_info :: epoch :: NAME , & self . epoch) ? ; state . serialize_field (crate :: prisma :: tick_info :: initial_tick :: NAME , & self . initial_tick) ? ; state . serialize_field (crate :: prisma :: tick_info :: created_at :: NAME , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , tick , duration , epoch , initial_tick , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tick_info :: $ field :: NAME) , + , crate :: prisma :: tick_info :: id :: NAME , crate :: prisma :: tick_info :: tick :: NAME , crate :: prisma :: tick_info :: duration :: NAME , crate :: prisma :: tick_info :: epoch :: NAME , crate :: prisma :: tick_info :: initial_tick :: NAME , crate :: prisma :: tick_info :: created_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tick_info :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: tick_info :: id :: NAME => Ok (Field :: id) , crate :: prisma :: tick_info :: tick :: NAME => Ok (Field :: tick) , crate :: prisma :: tick_info :: duration :: NAME => Ok (Field :: duration) , crate :: prisma :: tick_info :: epoch :: NAME => Ok (Field :: epoch) , crate :: prisma :: tick_info :: initial_tick :: NAME => Ok (Field :: initial_tick) , crate :: prisma :: tick_info :: created_at :: NAME => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut tick = None ; let mut duration = None ; let mut epoch = None ; let mut initial_tick = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: tick => { if tick . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: tick :: NAME)) ; } tick = Some (map . next_value () ?) ; } Field :: duration => { if duration . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: duration :: NAME)) ; } duration = Some (map . next_value () ?) ; } Field :: epoch => { if epoch . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: epoch :: NAME)) ; } epoch = Some (map . next_value () ?) ; } Field :: initial_tick => { if initial_tick . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: initial_tick :: NAME)) ; } initial_tick = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tick_info :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: id :: NAME)) ? ; let tick = tick . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: tick :: NAME)) ? ; let duration = duration . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: duration :: NAME)) ? ; let epoch = epoch . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: epoch :: NAME)) ? ; let initial_tick = initial_tick . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: initial_tick :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tick_info :: created_at :: NAME)) ? ; Ok (Data { id , tick , duration , epoch , initial_tick , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "tick" , "duration" , "epoch" , "initial_tick" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tick_info :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TickInfo" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tick_info :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; tick) => { "tick" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; epoch) => { "epoch" } ; (@ field_serde_name ; initial_tick) => { "initial_tick" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_tick_info as include;
    pub enum IncludeParam {
        Id(id::Include),
        Tick(tick::Include),
        Duration(duration::Include),
        Epoch(epoch::Include),
        InitialTick(initial_tick::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Tick(data) => data.to_selection(),
                Self::Duration(data) => data.to_selection(),
                Self::Epoch(data) => data.to_selection(),
                Self::InitialTick(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_tick_info { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: tick_info struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "tick")] pub tick : i64 , # [serde (rename = "duration")] pub duration : i64 , # [serde (rename = "epoch")] pub epoch : i32 , # [serde (rename = "initial_tick")] pub initial_tick : i64 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_tick_info as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "tick")]
        pub tick: i64,
        #[serde(rename = "duration")]
        pub duration: i64,
        #[serde(rename = "epoch")]
        pub epoch: i32,
        #[serde(rename = "initial_tick")]
        pub initial_tick: i64,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetTick(i64),
        IncrementTick(i64),
        DecrementTick(i64),
        MultiplyTick(i64),
        DivideTick(i64),
        SetDuration(i64),
        IncrementDuration(i64),
        DecrementDuration(i64),
        MultiplyDuration(i64),
        DivideDuration(i64),
        SetEpoch(i32),
        IncrementEpoch(i32),
        DecrementEpoch(i32),
        MultiplyEpoch(i32),
        DivideEpoch(i32),
        SetInitialTick(i64),
        IncrementInitialTick(i64),
        DecrementInitialTick(i64),
        MultiplyInitialTick(i64),
        DivideInitialTick(i64),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetDuration(value) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementDuration(value) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementDuration(value) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyDuration(value) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideDuration(value) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetEpoch(value) => (
                    epoch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementEpoch(value) => (
                    epoch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementEpoch(value) => (
                    epoch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyEpoch(value) => (
                    epoch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideEpoch(value) => (
                    epoch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetInitialTick(value) => (
                    initial_tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementInitialTick(value) => (
                    initial_tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementInitialTick(value) => (
                    initial_tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyInitialTick(value) => (
                    initial_tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideInitialTick(value) => (
                    initial_tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Tick(i64),
        Duration(i64),
        Epoch(i32),
        InitialTick(i64),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Tick(value) => Self::SetTick(value),
                UncheckedSetParam::Duration(value) => Self::SetDuration(value),
                UncheckedSetParam::Epoch(value) => Self::SetEpoch(value),
                UncheckedSetParam::InitialTick(value) => Self::SetInitialTick(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Tick(::prisma_client_rust::Direction),
        Duration(::prisma_client_rust::Direction),
        Epoch(::prisma_client_rust::Direction),
        InitialTick(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Tick(direction) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Duration(direction) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Epoch(direction) => (
                    epoch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::InitialTick(direction) => (
                    initial_tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Tick(_prisma::read_filters::BigIntFilter),
        Duration(_prisma::read_filters::BigIntFilter),
        Epoch(_prisma::read_filters::IntFilter),
        InitialTick(_prisma::read_filters::BigIntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Tick(value) => (tick::NAME, value.into()),
                Self::Duration(value) => (duration::NAME, value.into()),
                Self::Epoch(value) => (epoch::NAME, value.into()),
                Self::InitialTick(value) => (initial_tick::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(tick::NAME),
                ::prisma_client_rust::sel(duration::NAME),
                ::prisma_client_rust::sel(epoch::NAME),
                ::prisma_client_rust::sel(initial_tick::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            tick: i64,
            duration: i64,
            epoch: i32,
            initial_tick: i64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                tick::set(tick),
                duration::set(duration),
                epoch::set(epoch),
                initial_tick::set(initial_tick),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            tick: i64,
            duration: i64,
            epoch: i32,
            initial_tick: i64,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                tick::set(tick),
                duration::set(duration),
                epoch::set(epoch),
                initial_tick::set(initial_tick),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i64, i64, i32, i64, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(tick, duration, epoch, initial_tick, mut _params)| {
                    _params.extend([
                        tick::set(tick),
                        duration::set(duration),
                        epoch::set(epoch),
                        initial_tick::set(initial_tick),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (tick, duration, epoch, initial_tick, mut _params): (i64, i64, i32, i64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                tick::set(tick),
                duration::set(duration),
                epoch::set(epoch),
                initial_tick::set(initial_tick),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod tx_info {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "TxInfo";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "source_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSourceId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SourceId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SourceId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            SourceId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SourceId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SourceId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod dest_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dest_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDestId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DestId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DestId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DestId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DestId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DestId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DestId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod amount {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "amount";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAmount(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Amount(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Amount(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Amount(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            Amount,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementAmount(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementAmount(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyAmount(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideAmount(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Amount(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Amount(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod tick {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "tick";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTick(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Tick(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Tick(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Tick(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Tick, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementTick(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementTick(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyTick(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideTick(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Tick(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Tick(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod input_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "input_type";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetInputType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::InputType(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::InputType(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::InputType(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            InputType,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementInputType(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementInputType(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyInputType(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideInputType(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InputType(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InputType(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod input_size {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "input_size";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetInputSize(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::InputSize(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::InputSize(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::InputSize(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            InputSize,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementInputSize(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementInputSize(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyInputSize(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideInputSize(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InputSize(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InputSize(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod input_hex {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "input_hex";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetInputHex(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::InputHex(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::InputHex(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::InputHex(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            InputHex,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InputHex(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InputHex(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod signature_hex {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "signature_hex";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSignatureHex(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SignatureHex(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SignatureHex(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SignatureHex(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            SignatureHex,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SignatureHex(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SignatureHex(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod tx_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "tx_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTxId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TxId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TxId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TxId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, TxId, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TxId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TxId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod timestamp {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "timestamp";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTimestamp(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Timestamp(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Timestamp(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Timestamp,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Timestamp(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Timestamp(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod money_flew {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "money_flew";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMoneyFlew(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MoneyFlew(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MoneyFlew(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::MoneyFlew(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            MoneyFlew,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MoneyFlew(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MoneyFlew(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        source_id: String,
        dest_id: String,
        amount: i64,
        tick: i64,
        input_type: i32,
        input_size: i32,
        input_hex: String,
        signature_hex: String,
        tx_id: String,
        timestamp: String,
        money_flew: bool,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        i64,
        i64,
        i32,
        i32,
        String,
        String,
        String,
        String,
        bool,
        Vec<SetParam>,
    ) {
        (
            source_id,
            dest_id,
            amount,
            tick,
            input_type,
            input_size,
            input_hex,
            signature_hex,
            tx_id,
            timestamp,
            money_flew,
            _params,
        )
    }
    pub fn create_unchecked(
        source_id: String,
        dest_id: String,
        amount: i64,
        tick: i64,
        input_type: i32,
        input_size: i32,
        input_hex: String,
        signature_hex: String,
        tx_id: String,
        timestamp: String,
        money_flew: bool,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        i64,
        i64,
        i32,
        i32,
        String,
        String,
        String,
        String,
        bool,
        Vec<SetParam>,
    ) {
        (
            source_id,
            dest_id,
            amount,
            tick,
            input_type,
            input_size,
            input_hex,
            signature_hex,
            tx_id,
            timestamp,
            money_flew,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_tx_info { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tx_info :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tx_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tx_info :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tx_info :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tx_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tx_info :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , source_id , dest_id , amount , tick , input_type , input_size , input_hex , signature_hex , tx_id , timestamp , money_flew , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: tx_info :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tx_info :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tx_info :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tx_info :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "dest_id" , "amount" , "tick" , "input_type" , "input_size" , "input_hex" , "signature_hex" , "tx_id" , "timestamp" , "money_flew" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tx_info :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; source_id) => { String } ; (@ field_type ; dest_id) => { String } ; (@ field_type ; amount) => { i64 } ; (@ field_type ; tick) => { i64 } ; (@ field_type ; input_type) => { i32 } ; (@ field_type ; input_size) => { i32 } ; (@ field_type ; input_hex) => { String } ; (@ field_type ; signature_hex) => { String } ; (@ field_type ; tx_id) => { String } ; (@ field_type ; timestamp) => { String } ; (@ field_type ; money_flew) => { bool } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TxInfo" , available relations are "id, source_id, dest_id, amount, tick, input_type, input_size, input_hex, signature_hex, tx_id, timestamp, money_flew, created_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: id :: Select) } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: source_id :: Select) } ; (@ selection_field_to_selection_param ; dest_id) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: dest_id :: Select) } ; (@ selection_field_to_selection_param ; amount) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: amount :: Select) } ; (@ selection_field_to_selection_param ; tick) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: tick :: Select) } ; (@ selection_field_to_selection_param ; input_type) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: input_type :: Select) } ; (@ selection_field_to_selection_param ; input_size) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: input_size :: Select) } ; (@ selection_field_to_selection_param ; input_hex) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: input_hex :: Select) } ; (@ selection_field_to_selection_param ; signature_hex) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: signature_hex :: Select) } ; (@ selection_field_to_selection_param ; tx_id) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: tx_id :: Select) } ; (@ selection_field_to_selection_param ; timestamp) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: timestamp :: Select) } ; (@ selection_field_to_selection_param ; money_flew) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: money_flew :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: tx_info :: SelectParam > :: into (crate :: prisma :: tx_info :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tx_info :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; dest_id) => { "dest_id" } ; (@ field_serde_name ; amount) => { "amount" } ; (@ field_serde_name ; tick) => { "tick" } ; (@ field_serde_name ; input_type) => { "input_type" } ; (@ field_serde_name ; input_size) => { "input_size" } ; (@ field_serde_name ; input_hex) => { "input_hex" } ; (@ field_serde_name ; signature_hex) => { "signature_hex" } ; (@ field_serde_name ; tx_id) => { "tx_id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; money_flew) => { "money_flew" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_tx_info as select;
    pub enum SelectParam {
        Id(id::Select),
        SourceId(source_id::Select),
        DestId(dest_id::Select),
        Amount(amount::Select),
        Tick(tick::Select),
        InputType(input_type::Select),
        InputSize(input_size::Select),
        InputHex(input_hex::Select),
        SignatureHex(signature_hex::Select),
        TxId(tx_id::Select),
        Timestamp(timestamp::Select),
        MoneyFlew(money_flew::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::DestId(data) => data.to_selection(),
                Self::Amount(data) => data.to_selection(),
                Self::Tick(data) => data.to_selection(),
                Self::InputType(data) => data.to_selection(),
                Self::InputSize(data) => data.to_selection(),
                Self::InputHex(data) => data.to_selection(),
                Self::SignatureHex(data) => data.to_selection(),
                Self::TxId(data) => data.to_selection(),
                Self::Timestamp(data) => data.to_selection(),
                Self::MoneyFlew(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_tx_info { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tx_info :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tx_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tx_info :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tx_info :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tx_info :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tx_info :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tx_info :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tx_info :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub source_id : String , pub dest_id : String , pub amount : i64 , pub tick : i64 , pub input_type : i32 , pub input_size : i32 , pub input_hex : String , pub signature_hex : String , pub tx_id : String , pub timestamp : String , pub money_flew : bool , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: tx_info :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (source_id) , stringify ! (dest_id) , stringify ! (amount) , stringify ! (tick) , stringify ! (input_type) , stringify ! (input_size) , stringify ! (input_hex) , stringify ! (signature_hex) , stringify ! (tx_id) , stringify ! (timestamp) , stringify ! (money_flew) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tx_info :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: tx_info :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: tx_info :: source_id :: NAME , & self . source_id) ? ; state . serialize_field (crate :: prisma :: tx_info :: dest_id :: NAME , & self . dest_id) ? ; state . serialize_field (crate :: prisma :: tx_info :: amount :: NAME , & self . amount) ? ; state . serialize_field (crate :: prisma :: tx_info :: tick :: NAME , & self . tick) ? ; state . serialize_field (crate :: prisma :: tx_info :: input_type :: NAME , & self . input_type) ? ; state . serialize_field (crate :: prisma :: tx_info :: input_size :: NAME , & self . input_size) ? ; state . serialize_field (crate :: prisma :: tx_info :: input_hex :: NAME , & self . input_hex) ? ; state . serialize_field (crate :: prisma :: tx_info :: signature_hex :: NAME , & self . signature_hex) ? ; state . serialize_field (crate :: prisma :: tx_info :: tx_id :: NAME , & self . tx_id) ? ; state . serialize_field (crate :: prisma :: tx_info :: timestamp :: NAME , & self . timestamp) ? ; state . serialize_field (crate :: prisma :: tx_info :: money_flew :: NAME , & self . money_flew) ? ; state . serialize_field (crate :: prisma :: tx_info :: created_at :: NAME , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , source_id , dest_id , amount , tick , input_type , input_size , input_hex , signature_hex , tx_id , timestamp , money_flew , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tx_info :: $ field :: NAME) , + , crate :: prisma :: tx_info :: id :: NAME , crate :: prisma :: tx_info :: source_id :: NAME , crate :: prisma :: tx_info :: dest_id :: NAME , crate :: prisma :: tx_info :: amount :: NAME , crate :: prisma :: tx_info :: tick :: NAME , crate :: prisma :: tx_info :: input_type :: NAME , crate :: prisma :: tx_info :: input_size :: NAME , crate :: prisma :: tx_info :: input_hex :: NAME , crate :: prisma :: tx_info :: signature_hex :: NAME , crate :: prisma :: tx_info :: tx_id :: NAME , crate :: prisma :: tx_info :: timestamp :: NAME , crate :: prisma :: tx_info :: money_flew :: NAME , crate :: prisma :: tx_info :: created_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tx_info :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: tx_info :: id :: NAME => Ok (Field :: id) , crate :: prisma :: tx_info :: source_id :: NAME => Ok (Field :: source_id) , crate :: prisma :: tx_info :: dest_id :: NAME => Ok (Field :: dest_id) , crate :: prisma :: tx_info :: amount :: NAME => Ok (Field :: amount) , crate :: prisma :: tx_info :: tick :: NAME => Ok (Field :: tick) , crate :: prisma :: tx_info :: input_type :: NAME => Ok (Field :: input_type) , crate :: prisma :: tx_info :: input_size :: NAME => Ok (Field :: input_size) , crate :: prisma :: tx_info :: input_hex :: NAME => Ok (Field :: input_hex) , crate :: prisma :: tx_info :: signature_hex :: NAME => Ok (Field :: signature_hex) , crate :: prisma :: tx_info :: tx_id :: NAME => Ok (Field :: tx_id) , crate :: prisma :: tx_info :: timestamp :: NAME => Ok (Field :: timestamp) , crate :: prisma :: tx_info :: money_flew :: NAME => Ok (Field :: money_flew) , crate :: prisma :: tx_info :: created_at :: NAME => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut source_id = None ; let mut dest_id = None ; let mut amount = None ; let mut tick = None ; let mut input_type = None ; let mut input_size = None ; let mut input_hex = None ; let mut signature_hex = None ; let mut tx_id = None ; let mut timestamp = None ; let mut money_flew = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: source_id :: NAME)) ; } source_id = Some (map . next_value () ?) ; } Field :: dest_id => { if dest_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: dest_id :: NAME)) ; } dest_id = Some (map . next_value () ?) ; } Field :: amount => { if amount . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: amount :: NAME)) ; } amount = Some (map . next_value () ?) ; } Field :: tick => { if tick . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: tick :: NAME)) ; } tick = Some (map . next_value () ?) ; } Field :: input_type => { if input_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: input_type :: NAME)) ; } input_type = Some (map . next_value () ?) ; } Field :: input_size => { if input_size . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: input_size :: NAME)) ; } input_size = Some (map . next_value () ?) ; } Field :: input_hex => { if input_hex . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: input_hex :: NAME)) ; } input_hex = Some (map . next_value () ?) ; } Field :: signature_hex => { if signature_hex . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: signature_hex :: NAME)) ; } signature_hex = Some (map . next_value () ?) ; } Field :: tx_id => { if tx_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: tx_id :: NAME)) ; } tx_id = Some (map . next_value () ?) ; } Field :: timestamp => { if timestamp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: timestamp :: NAME)) ; } timestamp = Some (map . next_value () ?) ; } Field :: money_flew => { if money_flew . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: money_flew :: NAME)) ; } money_flew = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tx_info :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: id :: NAME)) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: source_id :: NAME)) ? ; let dest_id = dest_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: dest_id :: NAME)) ? ; let amount = amount . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: amount :: NAME)) ? ; let tick = tick . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: tick :: NAME)) ? ; let input_type = input_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: input_type :: NAME)) ? ; let input_size = input_size . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: input_size :: NAME)) ? ; let input_hex = input_hex . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: input_hex :: NAME)) ? ; let signature_hex = signature_hex . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: signature_hex :: NAME)) ? ; let tx_id = tx_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: tx_id :: NAME)) ? ; let timestamp = timestamp . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: timestamp :: NAME)) ? ; let money_flew = money_flew . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: money_flew :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tx_info :: created_at :: NAME)) ? ; Ok (Data { id , source_id , dest_id , amount , tick , input_type , input_size , input_hex , signature_hex , tx_id , timestamp , money_flew , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "dest_id" , "amount" , "tick" , "input_type" , "input_size" , "input_hex" , "signature_hex" , "tx_id" , "timestamp" , "money_flew" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tx_info :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TxInfo" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tx_info :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; dest_id) => { "dest_id" } ; (@ field_serde_name ; amount) => { "amount" } ; (@ field_serde_name ; tick) => { "tick" } ; (@ field_serde_name ; input_type) => { "input_type" } ; (@ field_serde_name ; input_size) => { "input_size" } ; (@ field_serde_name ; input_hex) => { "input_hex" } ; (@ field_serde_name ; signature_hex) => { "signature_hex" } ; (@ field_serde_name ; tx_id) => { "tx_id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; money_flew) => { "money_flew" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_tx_info as include;
    pub enum IncludeParam {
        Id(id::Include),
        SourceId(source_id::Include),
        DestId(dest_id::Include),
        Amount(amount::Include),
        Tick(tick::Include),
        InputType(input_type::Include),
        InputSize(input_size::Include),
        InputHex(input_hex::Include),
        SignatureHex(signature_hex::Include),
        TxId(tx_id::Include),
        Timestamp(timestamp::Include),
        MoneyFlew(money_flew::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::DestId(data) => data.to_selection(),
                Self::Amount(data) => data.to_selection(),
                Self::Tick(data) => data.to_selection(),
                Self::InputType(data) => data.to_selection(),
                Self::InputSize(data) => data.to_selection(),
                Self::InputHex(data) => data.to_selection(),
                Self::SignatureHex(data) => data.to_selection(),
                Self::TxId(data) => data.to_selection(),
                Self::Timestamp(data) => data.to_selection(),
                Self::MoneyFlew(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_tx_info { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: tx_info struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "source_id")] pub source_id : String , # [serde (rename = "dest_id")] pub dest_id : String , # [serde (rename = "amount")] pub amount : i64 , # [serde (rename = "tick")] pub tick : i64 , # [serde (rename = "input_type")] pub input_type : i32 , # [serde (rename = "input_size")] pub input_size : i32 , # [serde (rename = "input_hex")] pub input_hex : String , # [serde (rename = "signature_hex")] pub signature_hex : String , # [serde (rename = "tx_id")] pub tx_id : String , # [serde (rename = "timestamp")] pub timestamp : String , # [serde (rename = "money_flew")] pub money_flew : bool , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_tx_info as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "source_id")]
        pub source_id: String,
        #[serde(rename = "dest_id")]
        pub dest_id: String,
        #[serde(rename = "amount")]
        pub amount: i64,
        #[serde(rename = "tick")]
        pub tick: i64,
        #[serde(rename = "input_type")]
        pub input_type: i32,
        #[serde(rename = "input_size")]
        pub input_size: i32,
        #[serde(rename = "input_hex")]
        pub input_hex: String,
        #[serde(rename = "signature_hex")]
        pub signature_hex: String,
        #[serde(rename = "tx_id")]
        pub tx_id: String,
        #[serde(rename = "timestamp")]
        pub timestamp: String,
        #[serde(rename = "money_flew")]
        pub money_flew: bool,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSourceId(String),
        SetDestId(String),
        SetAmount(i64),
        IncrementAmount(i64),
        DecrementAmount(i64),
        MultiplyAmount(i64),
        DivideAmount(i64),
        SetTick(i64),
        IncrementTick(i64),
        DecrementTick(i64),
        MultiplyTick(i64),
        DivideTick(i64),
        SetInputType(i32),
        IncrementInputType(i32),
        DecrementInputType(i32),
        MultiplyInputType(i32),
        DivideInputType(i32),
        SetInputSize(i32),
        IncrementInputSize(i32),
        DecrementInputSize(i32),
        MultiplyInputSize(i32),
        DivideInputSize(i32),
        SetInputHex(String),
        SetSignatureHex(String),
        SetTxId(String),
        SetTimestamp(String),
        SetMoneyFlew(bool),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDestId(value) => (
                    dest_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetInputType(value) => (
                    input_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementInputType(value) => (
                    input_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementInputType(value) => (
                    input_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyInputType(value) => (
                    input_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideInputType(value) => (
                    input_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetInputSize(value) => (
                    input_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementInputSize(value) => (
                    input_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementInputSize(value) => (
                    input_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyInputSize(value) => (
                    input_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideInputSize(value) => (
                    input_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetInputHex(value) => (
                    input_hex::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetSignatureHex(value) => (
                    signature_hex::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTxId(value) => (
                    tx_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTimestamp(value) => (
                    timestamp::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMoneyFlew(value) => (
                    money_flew::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SourceId(String),
        DestId(String),
        Amount(i64),
        Tick(i64),
        InputType(i32),
        InputSize(i32),
        InputHex(String),
        SignatureHex(String),
        TxId(String),
        Timestamp(String),
        MoneyFlew(bool),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SourceId(value) => Self::SetSourceId(value),
                UncheckedSetParam::DestId(value) => Self::SetDestId(value),
                UncheckedSetParam::Amount(value) => Self::SetAmount(value),
                UncheckedSetParam::Tick(value) => Self::SetTick(value),
                UncheckedSetParam::InputType(value) => Self::SetInputType(value),
                UncheckedSetParam::InputSize(value) => Self::SetInputSize(value),
                UncheckedSetParam::InputHex(value) => Self::SetInputHex(value),
                UncheckedSetParam::SignatureHex(value) => Self::SetSignatureHex(value),
                UncheckedSetParam::TxId(value) => Self::SetTxId(value),
                UncheckedSetParam::Timestamp(value) => Self::SetTimestamp(value),
                UncheckedSetParam::MoneyFlew(value) => Self::SetMoneyFlew(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SourceId(::prisma_client_rust::Direction),
        DestId(::prisma_client_rust::Direction),
        Amount(::prisma_client_rust::Direction),
        Tick(::prisma_client_rust::Direction),
        InputType(::prisma_client_rust::Direction),
        InputSize(::prisma_client_rust::Direction),
        InputHex(::prisma_client_rust::Direction),
        SignatureHex(::prisma_client_rust::Direction),
        TxId(::prisma_client_rust::Direction),
        Timestamp(::prisma_client_rust::Direction),
        MoneyFlew(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SourceId(direction) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DestId(direction) => (
                    dest_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Amount(direction) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Tick(direction) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::InputType(direction) => (
                    input_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::InputSize(direction) => (
                    input_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::InputHex(direction) => (
                    input_hex::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SignatureHex(direction) => (
                    signature_hex::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TxId(direction) => (
                    tx_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Timestamp(direction) => (
                    timestamp::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MoneyFlew(direction) => (
                    money_flew::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        SourceId(_prisma::read_filters::StringFilter),
        DestId(_prisma::read_filters::StringFilter),
        Amount(_prisma::read_filters::BigIntFilter),
        Tick(_prisma::read_filters::BigIntFilter),
        InputType(_prisma::read_filters::IntFilter),
        InputSize(_prisma::read_filters::IntFilter),
        InputHex(_prisma::read_filters::StringFilter),
        SignatureHex(_prisma::read_filters::StringFilter),
        TxId(_prisma::read_filters::StringFilter),
        Timestamp(_prisma::read_filters::StringFilter),
        MoneyFlew(_prisma::read_filters::BoolFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::DestId(value) => (dest_id::NAME, value.into()),
                Self::Amount(value) => (amount::NAME, value.into()),
                Self::Tick(value) => (tick::NAME, value.into()),
                Self::InputType(value) => (input_type::NAME, value.into()),
                Self::InputSize(value) => (input_size::NAME, value.into()),
                Self::InputHex(value) => (input_hex::NAME, value.into()),
                Self::SignatureHex(value) => (signature_hex::NAME, value.into()),
                Self::TxId(value) => (tx_id::NAME, value.into()),
                Self::Timestamp(value) => (timestamp::NAME, value.into()),
                Self::MoneyFlew(value) => (money_flew::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(source_id::NAME),
                ::prisma_client_rust::sel(dest_id::NAME),
                ::prisma_client_rust::sel(amount::NAME),
                ::prisma_client_rust::sel(tick::NAME),
                ::prisma_client_rust::sel(input_type::NAME),
                ::prisma_client_rust::sel(input_size::NAME),
                ::prisma_client_rust::sel(input_hex::NAME),
                ::prisma_client_rust::sel(signature_hex::NAME),
                ::prisma_client_rust::sel(tx_id::NAME),
                ::prisma_client_rust::sel(timestamp::NAME),
                ::prisma_client_rust::sel(money_flew::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            source_id: String,
            dest_id: String,
            amount: i64,
            tick: i64,
            input_type: i32,
            input_size: i32,
            input_hex: String,
            signature_hex: String,
            tx_id: String,
            timestamp: String,
            money_flew: bool,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                source_id::set(source_id),
                dest_id::set(dest_id),
                amount::set(amount),
                tick::set(tick),
                input_type::set(input_type),
                input_size::set(input_size),
                input_hex::set(input_hex),
                signature_hex::set(signature_hex),
                tx_id::set(tx_id),
                timestamp::set(timestamp),
                money_flew::set(money_flew),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            source_id: String,
            dest_id: String,
            amount: i64,
            tick: i64,
            input_type: i32,
            input_size: i32,
            input_hex: String,
            signature_hex: String,
            tx_id: String,
            timestamp: String,
            money_flew: bool,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                source_id::set(source_id),
                dest_id::set(dest_id),
                amount::set(amount),
                tick::set(tick),
                input_type::set(input_type),
                input_size::set(input_size),
                input_hex::set(input_hex),
                signature_hex::set(signature_hex),
                tx_id::set(tx_id),
                timestamp::set(timestamp),
                money_flew::set(money_flew),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                i64,
                i64,
                i32,
                i32,
                String,
                String,
                String,
                String,
                bool,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        source_id,
                        dest_id,
                        amount,
                        tick,
                        input_type,
                        input_size,
                        input_hex,
                        signature_hex,
                        tx_id,
                        timestamp,
                        money_flew,
                        mut _params,
                    )| {
                        _params.extend([
                            source_id::set(source_id),
                            dest_id::set(dest_id),
                            amount::set(amount),
                            tick::set(tick),
                            input_type::set(input_type),
                            input_size::set(input_size),
                            input_hex::set(input_hex),
                            signature_hex::set(signature_hex),
                            tx_id::set(tx_id),
                            timestamp::set(timestamp),
                            money_flew::set(money_flew),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                source_id,
                dest_id,
                amount,
                tick,
                input_type,
                input_size,
                input_hex,
                signature_hex,
                tx_id,
                timestamp,
                money_flew,
                mut _params,
            ): (
                String,
                String,
                i64,
                i64,
                i32,
                i32,
                String,
                String,
                String,
                String,
                bool,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                source_id::set(source_id),
                dest_id::set(dest_id),
                amount::set(amount),
                tick::set(tick),
                input_type::set(input_type),
                input_size::set(input_size),
                input_hex::set(input_hex),
                signature_hex::set(signature_hex),
                tx_id::set(tx_id),
                timestamp::set(timestamp),
                money_flew::set(money_flew),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod balance {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Balance";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod address {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "address";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAddress(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Address(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Address(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Address(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Address,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Address(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Address(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod balance {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "balance";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBalance(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Balance(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Balance(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Balance(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            Balance,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementBalance(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementBalance(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyBalance(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideBalance(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Balance(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Balance(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod tick {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "tick";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTick(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Tick(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Tick(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Tick(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Tick, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementTick(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementTick(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyTick(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideTick(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Tick(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Tick(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn address_tick<T: From<UniqueWhereParam>>(address: String, tick: i64) -> T {
        UniqueWhereParam::AddressTickEquals(address, tick).into()
    }
    pub fn create(
        address: String,
        balance: i64,
        tick: i64,
        _params: Vec<SetParam>,
    ) -> (String, i64, i64, Vec<SetParam>) {
        (address, balance, tick, _params)
    }
    pub fn create_unchecked(
        address: String,
        balance: i64,
        tick: i64,
        _params: Vec<SetParam>,
    ) -> (String, i64, i64, Vec<SetParam>) {
        (address, balance, tick, _params)
    }
    #[macro_export]
    macro_rules ! _select_balance { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: balance :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: balance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: balance :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: balance :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: balance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: balance :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , address , balance , tick , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: balance :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: balance :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: balance :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: balance :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: balance :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: balance :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "address" , "balance" , "tick" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: balance :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; address) => { String } ; (@ field_type ; balance) => { i64 } ; (@ field_type ; tick) => { i64 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Balance" , available relations are "id, address, balance, tick, created_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: balance :: SelectParam > :: into (crate :: prisma :: balance :: id :: Select) } ; (@ selection_field_to_selection_param ; address) => { Into :: < crate :: prisma :: balance :: SelectParam > :: into (crate :: prisma :: balance :: address :: Select) } ; (@ selection_field_to_selection_param ; balance) => { Into :: < crate :: prisma :: balance :: SelectParam > :: into (crate :: prisma :: balance :: balance :: Select) } ; (@ selection_field_to_selection_param ; tick) => { Into :: < crate :: prisma :: balance :: SelectParam > :: into (crate :: prisma :: balance :: tick :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: balance :: SelectParam > :: into (crate :: prisma :: balance :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: balance :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; address) => { "address" } ; (@ field_serde_name ; balance) => { "balance" } ; (@ field_serde_name ; tick) => { "tick" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_balance as select;
    pub enum SelectParam {
        Id(id::Select),
        Address(address::Select),
        Balance(balance::Select),
        Tick(tick::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Address(data) => data.to_selection(),
                Self::Balance(data) => data.to_selection(),
                Self::Tick(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_balance { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: balance :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: balance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: balance :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: balance :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: balance :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: balance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: balance :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: balance :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub address : String , pub balance : i64 , pub tick : i64 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: balance :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (address) , stringify ! (balance) , stringify ! (tick) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: balance :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: balance :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: balance :: address :: NAME , & self . address) ? ; state . serialize_field (crate :: prisma :: balance :: balance :: NAME , & self . balance) ? ; state . serialize_field (crate :: prisma :: balance :: tick :: NAME , & self . tick) ? ; state . serialize_field (crate :: prisma :: balance :: created_at :: NAME , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , address , balance , tick , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: balance :: $ field :: NAME) , + , crate :: prisma :: balance :: id :: NAME , crate :: prisma :: balance :: address :: NAME , crate :: prisma :: balance :: balance :: NAME , crate :: prisma :: balance :: tick :: NAME , crate :: prisma :: balance :: created_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: balance :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: balance :: id :: NAME => Ok (Field :: id) , crate :: prisma :: balance :: address :: NAME => Ok (Field :: address) , crate :: prisma :: balance :: balance :: NAME => Ok (Field :: balance) , crate :: prisma :: balance :: tick :: NAME => Ok (Field :: tick) , crate :: prisma :: balance :: created_at :: NAME => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut address = None ; let mut balance = None ; let mut tick = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: balance :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: address => { if address . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: balance :: address :: NAME)) ; } address = Some (map . next_value () ?) ; } Field :: balance => { if balance . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: balance :: balance :: NAME)) ; } balance = Some (map . next_value () ?) ; } Field :: tick => { if tick . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: balance :: tick :: NAME)) ; } tick = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: balance :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: balance :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: balance :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: balance :: id :: NAME)) ? ; let address = address . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: balance :: address :: NAME)) ? ; let balance = balance . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: balance :: balance :: NAME)) ? ; let tick = tick . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: balance :: tick :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: balance :: created_at :: NAME)) ? ; Ok (Data { id , address , balance , tick , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "address" , "balance" , "tick" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: balance :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Balance" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: balance :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; address) => { "address" } ; (@ field_serde_name ; balance) => { "balance" } ; (@ field_serde_name ; tick) => { "tick" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_balance as include;
    pub enum IncludeParam {
        Id(id::Include),
        Address(address::Include),
        Balance(balance::Include),
        Tick(tick::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Address(data) => data.to_selection(),
                Self::Balance(data) => data.to_selection(),
                Self::Tick(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_balance { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: balance struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "address")] pub address : String , # [serde (rename = "balance")] pub balance : i64 , # [serde (rename = "tick")] pub tick : i64 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_balance as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "address")]
        pub address: String,
        #[serde(rename = "balance")]
        pub balance: i64,
        #[serde(rename = "tick")]
        pub tick: i64,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetAddress(String),
        SetBalance(i64),
        IncrementBalance(i64),
        DecrementBalance(i64),
        MultiplyBalance(i64),
        DivideBalance(i64),
        SetTick(i64),
        IncrementTick(i64),
        DecrementTick(i64),
        MultiplyTick(i64),
        DivideTick(i64),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetAddress(value) => (
                    address::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideTick(value) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Address(String),
        Balance(i64),
        Tick(i64),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Address(value) => Self::SetAddress(value),
                UncheckedSetParam::Balance(value) => Self::SetBalance(value),
                UncheckedSetParam::Tick(value) => Self::SetTick(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Address(::prisma_client_rust::Direction),
        Balance(::prisma_client_rust::Direction),
        Tick(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Address(direction) => (
                    address::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Balance(direction) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Tick(direction) => (
                    tick::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        AddressTickEquals(String, i64),
        Id(_prisma::read_filters::IntFilter),
        Address(_prisma::read_filters::StringFilter),
        Balance(_prisma::read_filters::BigIntFilter),
        Tick(_prisma::read_filters::BigIntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::AddressTickEquals(address, tick) => (
                    "address_tick",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            address::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::String(address),
                        ),
                        (
                            tick::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(tick),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Address(value) => (address::NAME, value.into()),
                Self::Balance(value) => (balance::NAME, value.into()),
                Self::Tick(value) => (tick::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        AddressTickEquals(String, i64),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::AddressTickEquals(address, tick) => {
                    Self::AddressTickEquals(address, tick)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(address::NAME),
                ::prisma_client_rust::sel(balance::NAME),
                ::prisma_client_rust::sel(tick::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            address: String,
            balance: i64,
            tick: i64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                address::set(address),
                balance::set(balance),
                tick::set(tick),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            address: String,
            balance: i64,
            tick: i64,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                address::set(address),
                balance::set(balance),
                tick::set(tick),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, i64, i64, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(address, balance, tick, mut _params)| {
                    _params.extend([
                        address::set(address),
                        balance::set(balance),
                        tick::set(tick),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (address, balance, tick, mut _params): (String, i64, i64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                address::set(address),
                balance::set(balance),
                tick::set(tick),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn tick_info(&self) -> super::tick_info::Actions {
            super::tick_info::Actions { client: &self.0 }
        }
        pub fn tx_info(&self) -> super::tx_info::Actions {
            super::tx_info::Actions { client: &self.0 }
        }
        pub fn balance(&self) -> super::balance::Actions {
            super::balance::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BalanceScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "address")]
        Address,
        #[serde(rename = "balance")]
        Balance,
        #[serde(rename = "tick")]
        Tick,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for BalanceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Address => "address".to_string(),
                Self::Balance => "balance".to_string(),
                Self::Tick => "tick".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TickInfoScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "tick")]
        Tick,
        #[serde(rename = "duration")]
        Duration,
        #[serde(rename = "epoch")]
        Epoch,
        #[serde(rename = "initial_tick")]
        InitialTick,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for TickInfoScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Tick => "tick".to_string(),
                Self::Duration => "duration".to_string(),
                Self::Epoch => "epoch".to_string(),
                Self::InitialTick => "initial_tick".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TxInfoScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "source_id")]
        SourceId,
        #[serde(rename = "dest_id")]
        DestId,
        #[serde(rename = "amount")]
        Amount,
        #[serde(rename = "tick")]
        Tick,
        #[serde(rename = "input_type")]
        InputType,
        #[serde(rename = "input_size")]
        InputSize,
        #[serde(rename = "input_hex")]
        InputHex,
        #[serde(rename = "signature_hex")]
        SignatureHex,
        #[serde(rename = "tx_id")]
        TxId,
        #[serde(rename = "timestamp")]
        Timestamp,
        #[serde(rename = "money_flew")]
        MoneyFlew,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for TxInfoScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SourceId => "source_id".to_string(),
                Self::DestId => "dest_id".to_string(),
                Self::Amount => "amount".to_string(),
                Self::Tick => "tick".to_string(),
                Self::InputType => "input_type".to_string(),
                Self::InputSize => "input_size".to_string(),
                Self::InputHex => "input_hex".to_string(),
                Self::SignatureHex => "signature_hex".to_string(),
                Self::TxId => "tx_id".to_string(),
                Self::Timestamp => "timestamp".to_string(),
                Self::MoneyFlew => "money_flew".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BigIntFilter {
            Equals(i64),
            InVec(Vec<i64>),
            NotInVec(Vec<i64>),
            Lt(i64),
            Lte(i64),
            Gt(i64),
            Gte(i64),
            Not(i64),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
